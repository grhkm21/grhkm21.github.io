<!DOCTYPE html>
<html lang="en-uk">


<script async src="https://www.googletagmanager.com/gtag/js?id=G-6BP6QGT61V"></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag() { dataLayer.push(arguments); }
    gtag('js', new Date());

    gtag('config', 'G-6BP6QGT61V');
</script>

<title>Learning Without Errors (396 pts, 6 solves, upsolve) | Blog by grhkm21</title>
<meta charset="utf-8">
<meta name="generator" content="Hugo 0.109.0">
<meta name="description" content="Chosen Plaintext Ring-LWE (CKKS) Attack">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet"
    href="https://grhkm21.github.io/css/index.css">
<link rel="canonical" href="https://grhkm21.github.io/posts/dice-learning-without-errors/">
<link rel="alternate" type="application/rss+xml" href=""
    title="Blog by grhkm21">

<script src="https://code.jquery.com/jquery-3.6.4.min.js"
    integrity="sha256-oP6HI9z1XaZNBrJURtCoUT5SUnxFr8s3BzRl+cbzUq8=" crossorigin="anonymous"></script>
<script defer src="https://grhkm21.github.io/js/spoiler.js"></script>




<link rel="stylesheet" href="/scss/hint.min.css">


<link rel="stylesheet" href="/scss/alert.min.css">


<link rel="stylesheet" href="https://grhkm21.github.io/katex/katex.min.css">
<script defer src="https://grhkm21.github.io/katex/katex.min.js"></script>
<script defer src="https://grhkm21.github.io/katex/contrib/auto-render.min.js"
    onload="renderMathInElement(document.body)"></script>

<link rel="stylesheet" href="https://grhkm21.github.io/katex/katex.min.css">
<script defer src="https://grhkm21.github.io/katex/katex.min.js"></script>
<script defer src="https://grhkm21.github.io/katex/contrib/auto-render.min.js"></script>
<script>
    document.addEventListener("DOMContentLoaded", function () {
        renderMathInElement(document.body, {
            
            
            delimiters: [
                { left: '$$', right: '$$', display: true },
                { left: '$', right: '$', display: false },
                { left: '\\(', right: '\\)', display: false },
                { left: '\\[', right: '\\]', display: true }
            ],
            
            throwOnError: false
        });
    });
</script>

<header>
    
    <a href="https://grhkm21.github.io/" class="title">Blog by grhkm21</a>
    
    
    <nav>
        
        <a href="/about-me/">About</a>
        
        <a href="/">Posts</a>
        
    </nav>
    
</header>

<article>
  <header>
    <h1>Learning Without Errors (396 pts, 6 solves, upsolve)</h1>
  </header>
  <p>(Up-)Solved by: grhkm</p>
<p>Source of the problem: <a href="https://ctf.dicega.ng/challs">Dice CTF 2022</a></p>
<h2 id="self-reflection">Self-Reflection</h2>
<p>I am actually very frustrated and annoyed at myself for this problem. During the CTF I was scared off by my lack of experience with this encryption scheme, and also just didn&rsquo;t believe I can solve this challenge. As a result, I spent a lot of my time watching YouTube instead.</p>
<p>Approaching the end of the CTF, for absolutely no reason I decided I will try to take a look at the challenge. I started the biggest crossover between the CTF and the speed-running community ever and seriously attempted the challenge in the last hour and half of the CTF. I watched a video on Homomorphic Encryption while I ate dinner, and an hour before the end of CTF I found the correct paper and started tracing the given <code>fhe</code> library. At the end I had the idea of the solution and was ready to start coding. But of course, it was also the end of CTF! After the contest, I finished coding my solution in around an hour, while debugging took me around 3 hours, mainly due to my unfamiliarity with the system. Nonetheless, I would have solved this if not due to my lack of confidence and if I actually spent time on this <em>crypto</em> challenge, which I am meant to excel in&hellip;</p>
<h2 id="problem-statement">Problem Statement</h2>
<blockquote>
<p>Choose Keys Karefully for Security</p>
<p><code>nc mc.ax 31614</code></p>
<p><a href="/files/lwe-server.py">server.py</a></p>
<p><a href="/files/lwe-challenge.py">challenge.py</a></p>
</blockquote>
<h2 id="solution-outline">Solution Outline</h2>
<p>The ciphertext-message pair leaks the secret key as a linear equation, and we can simply decrypt the flag. Yes, it&rsquo;s that simple.</p>
<h2 id="understanding-the-code">Understanding the Code</h2>
<p>Let&rsquo;s first try to understand the flow of the challenge by looking at <code>server.py</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">from</span> challenge <span style="color:#f92672">import</span> Challenge
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>poly_degree <span style="color:#f92672">=</span> <span style="color:#ae81ff">1024</span>
</span></span><span style="display:flex;"><span>ciph_modulus <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">100</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">&#39;Please hold, generating keys...&#39;</span>, flush<span style="color:#f92672">=</span><span style="color:#66d9ef">True</span>)
</span></span><span style="display:flex;"><span>chal <span style="color:#f92672">=</span> Challenge(poly_degree, ciph_modulus)
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">&#39;Welcome to the Encryption-As-A-Service Provider of the Future, powered by the latest in Fully-Homomorphic Encryption!&#39;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>data <span style="color:#f92672">=</span> input(<span style="color:#e6db74">&#39;Provide your complex vector as json to be encrypted: &#39;</span>)
</span></span><span style="display:flex;"><span>data <span style="color:#f92672">=</span> json<span style="color:#f92672">.</span>loads(data)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>ciph <span style="color:#f92672">=</span> chal<span style="color:#f92672">.</span>encrypt_json(data)
</span></span><span style="display:flex;"><span>string_ciph <span style="color:#f92672">=</span> json<span style="color:#f92672">.</span>dumps(chal<span style="color:#f92672">.</span>dump_ciphertext(ciph))
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">&#39;Encryption successful, here is your ciphertext:&#39;</span>, string_ciph)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>plain <span style="color:#f92672">=</span> chal<span style="color:#f92672">.</span>decrypt_ciphertext(ciph)
</span></span><span style="display:flex;"><span>string_plain <span style="color:#f92672">=</span> json<span style="color:#f92672">.</span>dumps(chal<span style="color:#f92672">.</span>dump_plaintext(plain))
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">&#39;To verify that the encryption worked, here is the corresponding decryption:&#39;</span>, string_plain)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>e_flag <span style="color:#f92672">=</span> chal<span style="color:#f92672">.</span>encrypt_flag()
</span></span><span style="display:flex;"><span>string_flag <span style="color:#f92672">=</span> json<span style="color:#f92672">.</span>dumps(chal<span style="color:#f92672">.</span>dump_ciphertext(e_flag))
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">&#39;All done, here</span><span style="color:#ae81ff">\&#39;</span><span style="color:#e6db74">s an encrypted flag as a reward:&#39;</span>, string_flag)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">&#39;Enjoy DiceCTF!&#39;</span>)
</span></span></code></pre></div><p>The cryptography-related functions are implemented in <code>challenge.py</code> instead.</p>
<ul>
<li>The server first asks for a message</li>
<li>It then encrypts the message by <code>encrypt_json</code>, and decrypts it the message by <code>decrypt_ciphertext</code></li>
<li>Finally, the server prints the encrypted flag from <code>encrypt_flag()</code></li>
</ul>
<p>In other words, we have to perform a Single Chosen Plaintext attack. Let&rsquo;s now take a look at <code>challenge.py</code>. Note that the script uses an external implementation of CKKS, which can be found at <a href="https://github.com/sarojaerabelli/py-fhe">sarojaerabelli/py-fhe</a>. I will refer to it as &ldquo;the library&rdquo; from now on.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e"># https://github.com/sarojaerabelli/py-fhe</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># imports omitted</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Challenge</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> __init__(self, poly_degree, ciph_modulus):
</span></span><span style="display:flex;"><span>        big_modulus <span style="color:#f92672">=</span> ciph_modulus<span style="color:#f92672">**</span><span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>        scaling_factor <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">30</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        params <span style="color:#f92672">=</span> CKKSParameters(poly_degree<span style="color:#f92672">=</span>poly_degree,
</span></span><span style="display:flex;"><span>                                ciph_modulus<span style="color:#f92672">=</span>ciph_modulus,
</span></span><span style="display:flex;"><span>                                big_modulus<span style="color:#f92672">=</span>big_modulus,
</span></span><span style="display:flex;"><span>                                scaling_factor<span style="color:#f92672">=</span>scaling_factor)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        key_generator <span style="color:#f92672">=</span> CKKSKeyGenerator(params)
</span></span><span style="display:flex;"><span>        public_key <span style="color:#f92672">=</span> key_generator<span style="color:#f92672">.</span>public_key
</span></span><span style="display:flex;"><span>        secret_key <span style="color:#f92672">=</span> key_generator<span style="color:#f92672">.</span>secret_key
</span></span><span style="display:flex;"><span>        encoder <span style="color:#f92672">=</span> CKKSEncoder(params)
</span></span><span style="display:flex;"><span>        encryptor <span style="color:#f92672">=</span> CKKSEncryptor(params, public_key, secret_key)
</span></span><span style="display:flex;"><span>        decryptor <span style="color:#f92672">=</span> CKKSDecryptor(params, secret_key)
</span></span><span style="display:flex;"><span>        evaluator <span style="color:#f92672">=</span> CKKSEvaluator(params)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># irrelevant code omitted</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">encrypt_flag</span>(self):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">with</span> open(<span style="color:#e6db74">&#34;flag.txt&#34;</span>, <span style="color:#e6db74">&#34;rb&#34;</span>) <span style="color:#66d9ef">as</span> f:
</span></span><span style="display:flex;"><span>            flag <span style="color:#f92672">=</span> f<span style="color:#f92672">.</span>read()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        n <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>poly_degree <span style="color:#f92672">//</span> <span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        flag <span style="color:#f92672">=</span> int<span style="color:#f92672">.</span>from_bytes(flag, <span style="color:#e6db74">&#34;big&#34;</span>)
</span></span><span style="display:flex;"><span>        flag <span style="color:#f92672">=</span> <span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">{</span>flag<span style="color:#e6db74">:</span><span style="color:#e6db74">0</span><span style="color:#e6db74">{</span>n<span style="color:#e6db74">}</span><span style="color:#e6db74">b</span><span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>        flag <span style="color:#f92672">=</span> [float(i) <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> flag]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        d <span style="color:#f92672">=</span> {<span style="color:#e6db74">&#34;real_part&#34;</span>: flag, <span style="color:#e6db74">&#34;imag_part&#34;</span>: [<span style="color:#ae81ff">0</span>] <span style="color:#f92672">*</span> n}
</span></span><span style="display:flex;"><span>        ciph <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>encrypt_json(d)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> ciph
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">dump_ciphertext</span>(self, ciph):
</span></span><span style="display:flex;"><span>        d <span style="color:#f92672">=</span> {<span style="color:#e6db74">&#34;c0&#34;</span> : ciph<span style="color:#f92672">.</span>c0<span style="color:#f92672">.</span>coeffs,
</span></span><span style="display:flex;"><span>             <span style="color:#e6db74">&#34;c1&#34;</span> : ciph<span style="color:#f92672">.</span>c1<span style="color:#f92672">.</span>coeffs,
</span></span><span style="display:flex;"><span>             <span style="color:#e6db74">&#34;poly_degree&#34;</span> : ciph<span style="color:#f92672">.</span>c0<span style="color:#f92672">.</span>ring_degree,
</span></span><span style="display:flex;"><span>             <span style="color:#e6db74">&#34;modulus&#34;</span> : ciph<span style="color:#f92672">.</span>modulus}
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> d
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">dump_plaintext</span>(self, plain):
</span></span><span style="display:flex;"><span>        d <span style="color:#f92672">=</span> {<span style="color:#e6db74">&#34;m&#34;</span> : plain<span style="color:#f92672">.</span>poly<span style="color:#f92672">.</span>coeffs,
</span></span><span style="display:flex;"><span>             <span style="color:#e6db74">&#34;poly_degree&#34;</span> : plain<span style="color:#f92672">.</span>poly<span style="color:#f92672">.</span>ring_degree,
</span></span><span style="display:flex;"><span>             <span style="color:#e6db74">&#34;scaling_factor&#34;</span> : plain<span style="color:#f92672">.</span>scaling_factor}
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> d
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">dump_decoded_plaintext</span>(self, plain):
</span></span><span style="display:flex;"><span>        x <span style="color:#f92672">=</span> [complex(i) <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> plain]
</span></span><span style="display:flex;"><span>        real <span style="color:#f92672">=</span> [i<span style="color:#f92672">.</span>real <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> plain]
</span></span><span style="display:flex;"><span>        imag <span style="color:#f92672">=</span> [i<span style="color:#f92672">.</span>imag <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> plain]
</span></span><span style="display:flex;"><span>        d <span style="color:#f92672">=</span> {<span style="color:#e6db74">&#34;real_part&#34;</span>: real, <span style="color:#e6db74">&#34;imag_part&#34;</span>: imag}
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> d
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">decrypt_ciphertext</span>(self, ciph):
</span></span><span style="display:flex;"><span>        plain <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>decryptor<span style="color:#f92672">.</span>decrypt(ciph)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> plain
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">decrypt_and_decode_ciphertext</span>(self, ciph):
</span></span><span style="display:flex;"><span>        plain <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>decryptor<span style="color:#f92672">.</span>decrypt(ciph)
</span></span><span style="display:flex;"><span>        plain <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>encoder<span style="color:#f92672">.</span>decode(plain)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> plain
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">encrypt_json</span>(self, d):
</span></span><span style="display:flex;"><span>        real <span style="color:#f92672">=</span> list(d[<span style="color:#e6db74">&#34;real_part&#34;</span>])
</span></span><span style="display:flex;"><span>        imag <span style="color:#f92672">=</span> list(d[<span style="color:#e6db74">&#34;imag_part&#34;</span>])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        message <span style="color:#f92672">=</span> [r <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>j <span style="color:#f92672">*</span> i <span style="color:#66d9ef">for</span> r,i <span style="color:#f92672">in</span> zip(real, imag)]
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">assert</span> len(message) <span style="color:#f92672">==</span> self<span style="color:#f92672">.</span>poly_degree <span style="color:#f92672">//</span> <span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        plain <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>encoder<span style="color:#f92672">.</span>encode(message, self<span style="color:#f92672">.</span>scaling_factor)
</span></span><span style="display:flex;"><span>        ciph <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>encryptor<span style="color:#f92672">.</span>encrypt(plain)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> ciph
</span></span></code></pre></div><p>There are quite a few functions to keep track of here. Here I highlight the library function calls.</p>
<ul>
<li><code>encrypt_json</code> → <code>encoder.encode</code>, <code>encryptor.encrypt</code></li>
<li><code>decrypt_ciphertext</code> → <code>decryptor.decrypt</code></li>
<li><code>encrypt_flag</code> → <code>encrypt_json</code> → <code>encoder.encode</code>, <code>encryptor.encrypt</code></li>
</ul>
<p>With this noted, let&rsquo;s try to solve the challenge. Before we do that, of course we have to know: what is CKKS???</p>
<h2 id="fully-homomorphic-encryption-fhe">Fully Homomorphic Encryption (FHE)</h2>
<p>To motivate the idea of <em>Fully Homomorphic Encryption</em> (FHE), imagine that you have two secret prime numbers (your crush&rsquo;s phone number and birthday!), $m_1$ and $m_2$, that you want to store in a secure cloud server. Obviously you should not trust the cloud, so you encrypted them as $c_1 := \text{enc}_{\text{pk}}(m_1)$ and $c_2 := \text{enc}_{\text{pk}}(m_2)$, and stored it into the cloud. Now suppose that you want to merge them together, which involves calculating $m_3 = m_1 \cdot m_2$. Of course, one way to do this is to decrypt both the messages, multiply them together, then encrypt and store it back. However, the cloud might intercept the decrypted messages, which is bad.</p>
<p>Here is when FHE will help - FHE allows you to calculate $c_3 = \text{enc}_{\text{pk}}(m_3)$ directly without knowing $m_1$ and $m_2$. In particular, there are operators $\oplus$ and $\otimes$ such that</p>
<p>$$\begin{align*} \text{enc}<em>{\text{pk}}(m_1)\ {\color{red}\oplus}\ \text{enc}</em>{\text{pk}}(m_2) &amp;= \text{enc}<em>{\text{pk}}(m_1\ {\color{cyan}+}\  m_2) \\ \text{enc}</em>{\text{pk}}(m_1)\ {\color{red}\otimes}\ \text{enc}<em>{\text{pk}}(m_2) &amp;= \text{enc}</em>{\text{pk}}(m_1\ {\color{cyan}\cdot}\ m_2) \end{align*}$$</p>
<p><img src="/images/dice-learning-with-errors-FHE.png" alt="Here, &amp;ldquo;easy&amp;rdquo; and &amp;ldquo;hard&amp;rdquo; is from the perspective of the cloud. It is easy to go right and down, but not up."></p>
<p>In other words, it allows one to perform computations over encrypted data without ever decrypting them. Notice the parallel between the <em>plaintext</em> space and the <em>ciphertext</em> space! This is why it is called a <em>homomorphic</em> scheme. This property is very useful and has practical uses, most importantly in cloud computing. I shall refer the reader to watch the first half of <a href="https://www.youtube.com/watch?v=9lTGEPJTw9M">this podcast</a>, which explains the concept in layman terms, and <a href="https://www.youtube.com/watch?v=TySXpV86958">this Eurocrypt 2019 talk</a>, which is a pretty clear talk.</p>
<h2 id="ckks-cheon-kim-kim-song-scheme">CKKS (Cheon-Kim-Kim-Song) Scheme</h2>
<p>The CKKS Encryption Scheme, named after Jung Hee Cheon, Andrey Kim, Miran Kim and Yongsoo Song, is a <em>Fully Homomorphic Encryption</em> (FHE) scheme <a href="https://eprint.iacr.org/2016/421.pdf">proposed</a> in 2016 that&rsquo;s based on approximate arithmetic. The core idea comes from the difficulty of Learning With Errors (LWE), that is, the difficulty of recovering the <em>secret</em> key $\vec{s}$ given only &ldquo;approximate&rdquo; random linear equations on $\vec{s}$. For example, it is hard to recover $\vec{s}$ given equations</p>
<p>$$\vec{b_i} = \vec{a_i}\cdot\vec{s} + \vec{e_i} \approx \vec{a_i}\cdot\vec{s}$$</p>
<p>Where $\vec{e_i}$ is the error term sampled from a secure error distribution $\chi$, usually chosen to be the normal distribution.</p>
<p>The scheme is fascinating and has a lot of details, but I will provide a simplified outline of the scheme to ease understanding. Hence, details such as scaling factors and relinearization will be left out. Interested readers shall refer to the original paper (linked) or <a href="https://eprint.iacr.org/2020/1533.pdf">[BD21, p.8]</a>.</p>
<h3 id="data-representation">Data Representation</h3>
<p>In the scheme, all operations are done with real polynomials of degree $\leq N$, where the coefficients are taken mod $q$. Our plaintext would be a complex vector, chosen as the evaluation of the polynomial at the primitive $(2N)$th roots of unity $\zeta^{2j + 1}$ for a few reasons.</p>
<p>First, notice that as these are primitive roots, they satisfy $x^N + 1 = 0$. This means that our polynomial can be reduced mod $x^N + 1$ and not affect the decoded vector, which means we can compute polynomial operations mod $x^N + 1$.</p>
<p>Furthermore, since we have $\zeta^{2j + 1} = \overline{\zeta^{-2j - 1}}$ as conjugate pairs and that our polynomial has real coefficients, we essentially get duplicate information: $P(\overline{x}) = \overline{P(x)}$. Hence, the scheme drops half of the roots of unity without losing information bits.</p>
<p>Finally, evaluation at roots of unity just screams FFT, which will greatly accelerate the calculations! From all this, we arrive at the following <em>decoding</em> function $\phi$:</p>
<p>$$\begin{align*} &amp;\mathcal{O} := \left(\mathbb{Z} / q\mathbb{Z}\right)[x] / (x^N + 1) \cong \left(\mathbb{Z} / q\mathbb{Z}\right)^N \\ &amp;\phi : \mathcal{O} \to \mathbb{C}^{\frac{N}{2}} \\ &amp;\phi(a(x)) \to \tilde{a} = \left(a(\zeta^{4j + 1})\right)_{j=0}^{\frac{N}{2} - 1} \end{align*}$$</p>
<p>Where the final expression is simply a vector of the valuation results. The <em>encoding</em> function is then simply $\phi^{-1}$. This is all implemented in the <code>py-fhe</code> library and can be done in sub-$O(N^2)$ time via FFT.</p>
<h3 id="key-generation">Key Generation</h3>
<p>Obviously, the scheme requires a public key and a secret key. In the <em>actual</em> CKKS scheme, there are also <em>switching</em> keys and <em>relinearization</em> keys, which I think will only further confuse matters and hence will be omitted.</p>
<p>Firstly, we choose an error distribution $\chi$ and a secret distribution $\chi&rsquo;$. As mentioned, the scheme is proven to be secure for normal distributions $\chi$ and $\chi&rsquo;$. However, for efficiency reasons, simpler distributions are chosen for the scheme. Here, the error distribution is</p>
<p>$$\chi = \{-1, 0, 1\}^n$$</p>
<p>Where for each of the $n$ entries, $-1, 0, 1$ have probability $25\%, 50\%$ and $25\%$ respectively. On the other hand, the secret distribution $\chi_h&rsquo;$ is</p>
<p>$$\chi_h&rsquo; = \{\vec{s} \in \{0, \pm 1\}^n : \sum_{i=1}^n |s_i| = h\}$$</p>
<p>i.e. the set of signed binary vectors where the hamming weight is exactly $h$, and each term has equal probability.</p>
<p>Let&rsquo;s write $a \gets \chi$ to mean &ldquo;sample the variable $a$ from $\chi$&rdquo;. From here, it is easy to describe our keys:</p>
<ul>
<li>Sample a secret polynomial $s$ with coefficients $\gets \chi_h&rsquo;$ with hamming weight $h = \frac{N}{4}$.</li>
<li>Sample a polynomial $a \gets \mathcal{O}$ (uniformly), and an error term $e \gets \chi$.</li>
<li>Then, our secret key is $\text{sk} = s \in \mathcal{O}$, and</li>
<li>Our public key is $\text{pk} = (p_1, p_2) = (-as + e, a) \in \mathcal{O}^2$.</li>
</ul>
<h3 id="encryption">Encryption</h3>
<p>The encryption algorithm $\text{enc}_{\text{pk}}(m)$ is also simple:</p>
<ul>
<li>First, sample polynomial $u \gets \chi$ and two errors $(e_1, e_2) \gets \chi^2$.</li>
<li>Then, our encrypted message is $\text{ct} = (c_1, c_2) := (m + p_1u + e_1, p_2u + e_2)$.</li>
</ul>
<h3 id="approximated-decryption">Approximated Decryption</h3>
<p>The approximated decryption algorithm $\text{dec}_{\text{sk}}(\text{ct})$ is even simpler:</p>
<ul>
<li>Our decrypted message is $m \approx c_1 + sc_2$.</li>
</ul>
<p>Notice how it&rsquo;s called approximated decryption. This is because expanding the calculation by decrypting the encrypted results, we have</p>
<p>$$\begin{align*} m &amp;\approx c_1 + sc_2 \\ &amp;= (m + p_1u + e_1) + s(p_2u + e_2) \\ &amp;= (m + e_1 + se_2) + \underbrace{(-as + e)}<em>{p_1}u + \underbrace{a}</em>{p_2}su \\ &amp;= m + (e_1 + se_2 + eu) \mod q \end{align*}$$</p>
<p>However, $e_1 + se_2 + eu$ is small, as $e, e_1, e_2$ and $u$ are all chosen from $\chi$ which gives small polynomials. Therefore, the decrypted results are &ldquo;close enough&rdquo; to the original message.</p>
<hr>
<h2 id="hidden-in-plain-sight">Hidden in Plain Sight</h2>
<p>Phew. That was a lot of maths to unpack. However, it is a lot easier from here.</p>
<p>Looking back at our challenge, we are able to supply $m$ and receive</p>
<p>$$\begin{align*} \text{enc}_{\text{pk}}(m) &amp;= (c_1, c_2) = \ldots \\ \text{dec}_{sk}(\text{enc}_{pk}(m)) &amp;= c_1 + sc_2 = \ldots \\ \text{enc}_{\text{pk}}(flag) &amp;= \ldots\end{align*}$$</p>
<p>Wait&hellip; this means that we are given $c_1, c_2, c_1 + sc_2$. Of course, we can recover $s$! Our $m$ doesn&rsquo;t even matter. Let&rsquo;s code this up and see:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">import</span> json
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> pwn <span style="color:#f92672">import</span> <span style="color:#f92672">*</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>q <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">100</span> <span style="color:#75715e"># ciph_modulus</span>
</span></span><span style="display:flex;"><span>N <span style="color:#f92672">=</span> <span style="color:#ae81ff">1024</span> <span style="color:#75715e"># poly_degree</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>r <span style="color:#f92672">=</span> remote(<span style="color:#e6db74">&#39;mc.ax&#39;</span>, <span style="color:#ae81ff">31614</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># receive our data</span>
</span></span><span style="display:flex;"><span>zeros <span style="color:#f92672">=</span> [float(<span style="color:#ae81ff">0.0</span>)] <span style="color:#f92672">*</span> (N <span style="color:#f92672">//</span> <span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>r<span style="color:#f92672">.</span>recvuntil(<span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;to be encrypted: &#39;</span>)
</span></span><span style="display:flex;"><span>r<span style="color:#f92672">.</span>sendline(json<span style="color:#f92672">.</span>dumps({<span style="color:#e6db74">&#34;real_part&#34;</span>: zeros, <span style="color:#e6db74">&#34;imag_part&#34;</span>: zeros})<span style="color:#f92672">.</span>encode())
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>ct <span style="color:#f92672">=</span> eval(r<span style="color:#f92672">.</span>recvline()<span style="color:#f92672">.</span>decode()<span style="color:#f92672">.</span>strip()<span style="color:#f92672">.</span>split(<span style="color:#e6db74">&#39;ciphertext: &#39;</span>)[<span style="color:#ae81ff">1</span>])
</span></span><span style="display:flex;"><span>msg <span style="color:#f92672">=</span> eval(r<span style="color:#f92672">.</span>recvline()<span style="color:#f92672">.</span>decode()<span style="color:#f92672">.</span>strip()<span style="color:#f92672">.</span>split(<span style="color:#e6db74">&#39;decryption: &#39;</span>)[<span style="color:#ae81ff">1</span>])
</span></span><span style="display:flex;"><span>flag <span style="color:#f92672">=</span> eval(r<span style="color:#f92672">.</span>recvline()<span style="color:#f92672">.</span>decode()<span style="color:#f92672">.</span>strip()<span style="color:#f92672">.</span>split(<span style="color:#e6db74">&#39;reward: &#39;</span>)[<span style="color:#ae81ff">1</span>])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># these are coefficients of the actual polynomials</span>
</span></span><span style="display:flex;"><span>msg_c0, msg_c1, msg_dec <span style="color:#f92672">=</span> ct[<span style="color:#e6db74">&#39;c0&#39;</span>], ct[<span style="color:#e6db74">&#39;c1&#39;</span>], msg[<span style="color:#e6db74">&#39;m&#39;</span>]
</span></span><span style="display:flex;"><span>flag_c0, flag_c1 <span style="color:#f92672">=</span> flag[<span style="color:#e6db74">&#39;c0&#39;</span>], flag[<span style="color:#e6db74">&#39;c1&#39;</span>]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># convert to our polynomials</span>
</span></span><span style="display:flex;"><span>R<span style="color:#f92672">.&lt;</span>x<span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span> PolynomialRing(Zmod(q), <span style="color:#e6db74">&#39;x&#39;</span>)<span style="color:#f92672">.</span>quotient(x<span style="color:#f92672">^</span>N <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>to_poly <span style="color:#f92672">=</span> <span style="color:#66d9ef">lambda</span> arr: sum(arr[i] <span style="color:#f92672">*</span> x<span style="color:#f92672">^</span>i <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(len(arr)))
</span></span><span style="display:flex;"><span>msg_c0, msg_c1, msg_dec, flag_c0, flag_c1 <span style="color:#f92672">=</span> map(to_poly, [msg_c0, msg_c1, msg_dec, flag_c0, flag_c1])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># as derived, msg_dec = msg_c0 + secret * msg_c1</span>
</span></span><span style="display:flex;"><span>secret <span style="color:#f92672">=</span> (msg_dec <span style="color:#f92672">-</span> msg_c0) <span style="color:#f92672">/</span> msg_c1
</span></span><span style="display:flex;"><span>print(secret)
</span></span></code></pre></div><p>Output:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#a6e22e">NotImplementedError</span>: The base ring (<span style="color:#f92672">=</span>Ring of integers modulo <span style="color:#ae81ff">1267650600228229401496703205376</span>) <span style="color:#f92672">is</span> <span style="color:#f92672">not</span> a field
</span></span></code></pre></div><p>Fuck sage &lt;3</p>
<h2 id="problem-1-cant-invert">Problem 1: Can&rsquo;t invert</h2>
<p>As shown by the error, Sage is not able to compute the inverse of <code>msg_c1</code>, required to divide, since $\mathbb{Z} / q\mathbb{Z}$ is not a field. For example, $2$ does not have an inverse $\mod q$, since $q = 2^{100}$. However, some elements are still invertible, and Sage is not able to calculate them. We can attempt to implement our own division instead of using Sage&rsquo;s,</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e"># ax + by = 1</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">xgcd</span>(a, b):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> b <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    g, x, y <span style="color:#f92672">=</span> xgcd(b, a <span style="color:#f92672">%</span> b) <span style="color:#75715e"># fill in the blanks</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> g, y <span style="color:#f92672">-</span> (b <span style="color:#f92672">//</span> a) <span style="color:#f92672">*</span> x, x
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">inverse</span>(a, b):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> xgcd(a, b)[<span style="color:#ae81ff">1</span>]
</span></span></code></pre></div><p>However, the algorithm still requires division, which is not always possible. We need a better way&hellip;</p>
<h2 id="fix-1-use-gareth-theorem">Fix 1: Use Gareth T.(heorem)</h2>
<p>As we mentioned, $2$ does not have an inverse $\mod q$. However, it is easy to see that all odd numbers $n = 2k + 1$ has an inverse. Let&rsquo;s look the inverse:</p>
<p>$$\frac{1}{n} = \frac{1}{1 + 2k} \stackrel{?}{=} \sum_{i=0}^{\infty} (-2k)^i\mod 2^{100}$$</p>
<p>Where the last (in)equality follows from a geometric series expansion. Now, notice that $(-2)^{-i}$ is actually eventually non-zero modulo $2^{100}$! In particular, we only have to sum the first $99$ terms of the series:</p>
<p>$$\frac{1}{1 + 2k} \equiv \sum_{i=0}^{99} (-2k)^{i}\mod 2^{100}$$</p>
<p>One can prove this by copying the proof of geometric series - multiply by $(-2k)$, subtract and divide. However, I prefer a better method: Prove by AC.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">while</span> <span style="color:#66d9ef">True</span>:
</span></span><span style="display:flex;"><span>    k <span style="color:#f92672">=</span> randint(<span style="color:#ae81ff">0</span>, q <span style="color:#f92672">//</span> <span style="color:#ae81ff">2</span>) <span style="color:#f92672">*</span> <span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">assert</span> sum(pow(<span style="color:#f92672">-</span>k, <span style="color:#f92672">-</span>i, q) <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">100</span>)) <span style="color:#f92672">*</span> (<span style="color:#ae81ff">1</span> <span style="color:#f92672">+</span> k) <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>
</span></span></code></pre></div><p>Now, we can try to apply this for invertible polynomials in general. It is not hard to prove that polynomials are only invertible if their constant term is odd. For such polynomials, we can write $P(x) = c_0P_1(x) = c_0(1 + Q(x))$, where $c_0$ is the constant term. Then,</p>
<p>$$\begin{align*} \frac{1}{P(x)} &amp;= \frac{1}{c_0}\cdot\frac{1}{1 + Q(x)} \ &amp;\equiv c_0^{-1}\sum_{i=0}^{\infty} (-Q(x))^i \mod (x^N + 1) \end{align*}$$</p>
<p>However, it turns out that this method doesn&rsquo;t always converge for all invertible polynomials - in fact, it converges for about 50% of the time, and a proof is included at the end. Moreover, the theoretical upper-bound for the converging $j$ is $2^{111}$, which would be impossible to compute with the $O(j)$ series. However, <em>numerical evidence</em> shows that $j$ is usually smaller. For reference, $j\leq 2^{15}$ for about 3% of the cases, and $j\leq 2^{16}$ for about 13%. (Keep in mind that it is polynomial arithmetic, and I am lazy to implement FFT). Therefore, we can assume that $j = 2^{16}$ is an upper bound and simply binary search for it.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e"># notice we change the definition to without quotient</span>
</span></span><span style="display:flex;"><span>R<span style="color:#f92672">.&lt;</span>x<span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span> PolynomialRing(Zmod(q), <span style="color:#e6db74">&#39;x&#39;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">inverse</span>(a):
</span></span><span style="display:flex;"><span>    c0 <span style="color:#f92672">=</span> a[<span style="color:#ae81ff">0</span>]
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">assert</span> c0 <span style="color:#f92672">%</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Q is the geometric series ratio</span>
</span></span><span style="display:flex;"><span>    a <span style="color:#f92672">/=</span> c0
</span></span><span style="display:flex;"><span>    Q <span style="color:#f92672">=</span> a <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># find bounds</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">assert</span> pow(Q, <span style="color:#ae81ff">2</span><span style="color:#f92672">^</span><span style="color:#ae81ff">32</span>, x<span style="color:#f92672">^</span>N <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    upper <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span><span style="color:#f92672">^</span><span style="color:#ae81ff">32</span>
</span></span><span style="display:flex;"><span>    lower <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    result <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> upper <span style="color:#f92672">&gt;=</span> lower:
</span></span><span style="display:flex;"><span>        mid <span style="color:#f92672">=</span> (lower <span style="color:#f92672">+</span> upper) <span style="color:#f92672">//</span> <span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> pow(<span style="color:#f92672">-</span>Q, mid, x<span style="color:#f92672">^</span>N <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>:
</span></span><span style="display:flex;"><span>            result <span style="color:#f92672">=</span> mid
</span></span><span style="display:flex;"><span>            upper <span style="color:#f92672">=</span> mid <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>            lower <span style="color:#f92672">=</span> mid <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># sum and return</span>
</span></span><span style="display:flex;"><span>    total <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    cur <span style="color:#f92672">=</span>  <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> tqdm(range(result)):
</span></span><span style="display:flex;"><span>        total <span style="color:#f92672">+=</span> cur
</span></span><span style="display:flex;"><span>        cur <span style="color:#f92672">=</span> cur <span style="color:#f92672">*</span> <span style="color:#f92672">-</span>Q <span style="color:#f92672">%</span> (x<span style="color:#f92672">^</span>N <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> total <span style="color:#f92672">/</span> Mod(c0, q)
</span></span></code></pre></div><p>Run it on <code>inverse(R(3))</code>, and</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>------------------------------------------------------------------------
</span></span><span style="display:flex;"><span><span style="color:#f92672">(</span>no backtrace available<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>------------------------------------------------------------------------
</span></span><span style="display:flex;"><span>Unhandled SIGABRT: An abort<span style="color:#f92672">()</span> occurred.
</span></span><span style="display:flex;"><span>This probably occurred because a *compiled* module has a bug
</span></span><span style="display:flex;"><span>in it and is not properly wrapped with sig_on<span style="color:#f92672">()</span>, sig_off<span style="color:#f92672">()</span>.
</span></span><span style="display:flex;"><span>Python will now terminate.
</span></span><span style="display:flex;"><span>------------------------------------------------------------------------
</span></span><span style="display:flex;"><span>/usr/local/bin/sage: line 19: <span style="color:#ae81ff">51248</span> Abort trap: <span style="color:#ae81ff">6</span>           <span style="color:#e6db74">&#34;</span>$SYMLINK<span style="color:#e6db74">/local/bin/sage&#34;</span> <span style="color:#e6db74">&#34;</span>$@<span style="color:#e6db74">&#34;</span>
</span></span></code></pre></div><p>???????</p>
<h2 id="bug-2-sage-whats-wrong-with-you">Bug 2: Sage, What&rsquo;s Wrong With You?</h2>
<p>To this day, I still have no idea why <code>pow</code> fails even with <code>int</code> exponents. I discovered this code in <code>polynomial_modn_dense_ntl.pyx</code>, but&hellip; ?:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">if</span> not isinstance(modulus, Polynomial_dense_modn_ntl_ZZ)<span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    modulus <span style="color:#f92672">=</span> self.parent()._coerce_(modulus)
</span></span><span style="display:flex;"><span>ZZ_pX_Modulus_build(mod[<span style="color:#ae81ff">0</span>], (<span style="color:#f92672">&lt;</span>Polynomial_dense_modn_ntl_ZZ<span style="color:#f92672">&gt;</span>modulus).x)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>do_sig <span style="color:#f92672">=</span> ZZ_pX_deg(self.x) <span style="color:#f92672">*</span> e <span style="color:#f92672">*</span> self.c.p_bits <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">1e5</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> do_sig: sig_on()
</span></span><span style="display:flex;"><span>ZZ_pX_PowerMod_long_pre(r.x, self.x, e, mod[<span style="color:#ae81ff">0</span>])
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> do_sig: sig_off()
</span></span></code></pre></div><p>Anyways, the fix for this is pretty simple.</p>
<h2 id="fix-2-take-matters-into-my-own-hands">Fix 2: Take Matters Into My Own Hands</h2>
<p>Since Sage refuses work and never works, I wrote my own pow implementation:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">qpow</span>(a, b, m):
</span></span><span style="display:flex;"><span>    res <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> b <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> b <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">1</span>:
</span></span><span style="display:flex;"><span>            res <span style="color:#f92672">=</span> res <span style="color:#f92672">*</span> a <span style="color:#f92672">%</span> m
</span></span><span style="display:flex;"><span>        a <span style="color:#f92672">=</span> a <span style="color:#f92672">*</span> a <span style="color:#f92672">%</span> m
</span></span><span style="display:flex;"><span>        b <span style="color:#f92672">&gt;&gt;=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> res
</span></span></code></pre></div><h2 id="final-step">Final Step</h2>
<p>With this, our code finally runs, at least 50% of the time (due to the polynomial being invertible 50% of the time). It takes a while, but after we recover the secret, we can compute the decrypted flag and <em>decode</em> for the flag.</p>

<div class="alert alert-info" role="alert"><p>Can&rsquo;t be me who forgot to decode the flag and spent 1.5 hours trying to figure this out. Remember this?</p>
</div>

<ul>
<li><code>encrypt_json</code> → <code>encoder.encode</code>, <code>encryptor.encrypt</code></li>
<li><code>decrypt_ciphertext</code> → <code>decryptor.decrypt</code></li>
<li><code>encrypt_flag</code> → <code>encrypt_json</code> → <code>encoder.encode</code>, <code>encryptor.encrypt</code></li>
</ul>
<p>Relevant code:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e"># setup secret key, mapping q - 1 to -1</span>
</span></span><span style="display:flex;"><span>coef <span style="color:#f92672">=</span> list(map(ZZ, secret<span style="color:#f92672">.</span>coefficients(sparse<span style="color:#f92672">=</span><span style="color:#66d9ef">False</span>)))
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">while</span> len(coef) <span style="color:#f92672">&lt;</span> N:
</span></span><span style="display:flex;"><span>    coef<span style="color:#f92672">.</span>append(<span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(N):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> coef[i] <span style="color:#f92672">==</span> q <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>:
</span></span><span style="display:flex;"><span>        coef[i] <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>secret <span style="color:#f92672">=</span> SecretKey(Polynomial(N, coef))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># decoder</span>
</span></span><span style="display:flex;"><span>big_modulus <span style="color:#f92672">=</span> q <span style="color:#f92672">**</span> <span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>scaling_factor <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">30</span>
</span></span><span style="display:flex;"><span>params <span style="color:#f92672">=</span> CKKSParameters(
</span></span><span style="display:flex;"><span>    poly_degree<span style="color:#f92672">=</span>N,
</span></span><span style="display:flex;"><span>    ciph_modulus<span style="color:#f92672">=</span>q,
</span></span><span style="display:flex;"><span>    big_modulus<span style="color:#f92672">=</span>big_modulus,
</span></span><span style="display:flex;"><span>    scaling_factor<span style="color:#f92672">=</span>scaling_factor,
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># use py-fhe library</span>
</span></span><span style="display:flex;"><span>decryptor <span style="color:#f92672">=</span> CKKSDecryptor(params, secret)
</span></span><span style="display:flex;"><span>flag_c0 <span style="color:#f92672">=</span> Polynomial(N, flag_c0<span style="color:#f92672">.</span>coefficients(sparse<span style="color:#f92672">=</span><span style="color:#66d9ef">False</span>))
</span></span><span style="display:flex;"><span>flag_c1 <span style="color:#f92672">=</span> Polynomial(N, flag_c1<span style="color:#f92672">.</span>coefficients(sparse<span style="color:#f92672">=</span><span style="color:#66d9ef">False</span>))
</span></span><span style="display:flex;"><span>flag <span style="color:#f92672">=</span> decryptor<span style="color:#f92672">.</span>decrypt(Ciphertext(flag_c0, flag_c1, scaling_factor<span style="color:#f92672">=</span>scaling_factor, modulus<span style="color:#f92672">=</span>q))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>encoder <span style="color:#f92672">=</span> CKKSEncoder(params)
</span></span><span style="display:flex;"><span>flag <span style="color:#f92672">=</span> encoder<span style="color:#f92672">.</span>decode(flag)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>flag <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;&#39;</span><span style="color:#f92672">.</span>join(map(str, [round(r<span style="color:#f92672">.</span>real()) <span style="color:#66d9ef">for</span> r <span style="color:#f92672">in</span> arr]))
</span></span><span style="display:flex;"><span>flag <span style="color:#f92672">=</span> bytes<span style="color:#f92672">.</span>fromhex(<span style="color:#e6db74">&#39;</span><span style="color:#e6db74">{:64x}</span><span style="color:#e6db74">&#39;</span><span style="color:#f92672">.</span>format(flag))
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;Flag: </span><span style="color:#e6db74">{</span>flag<span style="color:#f92672">.</span>decode()<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>)
</span></span></code></pre></div><p>With all this done, we simply have to run our script, extract the real part of each complex number, and get the flag~</p>
<p>Flag: <code>dice{this_destroyes_the_CKKS_cryptosystem_a3b31e683b82b26f}</code></p>
<p>Thank you for reading this blog, and thank you to @ireland for the challenge. Also thank you @Mystiz for suggesting the title &ldquo;Gareth T&rdquo;, it&rsquo;s a singer in Hong Kong :D Still wish I solved this during the CTF though :3</p>
<!-- raw HTML omitted -->
<h2 id="appendix-proof">Appendix: Proof</h2>
<p>Below, I will prove that for $N = 2^{10}$ and $q = 2^{100}$, as it is in the scheme, then</p>
<p>$$P(x)\equiv 0\mod (2, x + 1)\implies \lim_{n\to\infty} P(x)^{2^n}\equiv 0\mod (q, x^N + 1).$$</p>
<p>In other words, our geometric series converges if $(x + 1)$ is a factor of $P(x)$ mod $2$. Thank you @jschnei for the proof idea!</p>
<p><em>Proof:</em></p>
<p>If $(x + 1)\mid P(x)\mod 2$, then we can write $P(x) = (x + 1)Q(x)$. By Freshman&rsquo;s Dream, we know that</p>
<p>$$(x + 1)^N\equiv x^N + 1\mod 2.$$</p>
<p>Raising this to the $100^{\text{th}}$ power, we have</p>
<p>$$\begin{align*} (x + 1)^{100N}&amp;\equiv (x^N + 1)^{100} &amp;\mod q \\ (x + 1)^{100N} &amp;\equiv 0 &amp;\mod (q, x^N + 1) \end{align*}$$</p>
<p>Therefore, $P(x)^{100N} = P(x)^{102400}$ will converge to $0$.</p>
<p>It is not clear what happens when $(x + 1)$ is not a divisor of $P(x)$.</p>
<p><em>Update:</em> Woohoo! @jschnei is back with another update! Thank you once again.</p>
<p>Apparently, having an even constant term in the polynomial doesn&rsquo;t mean we can&rsquo;t invert the polynomial. Example? $x^{1024} + 2$.</p>
<p>Motivated by this, we simply consider $P(x) + (x^{1024} + 1)$ if the constant term is even, and if $(x + 1)\mid P(x)$, then $(x + 1)\mid P(x) + (x^{1024} + 1)$ by factor theorem and we proceed as above!</p>

</article>





</html>